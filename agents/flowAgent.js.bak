/**
 * Flow Agent for Proposal Generator using Responses API
 * 
 * This module orchestrates the end-to-end flow of the proposal generation process
 * using OpenAI's Responses API for improved parallelism and context management.
 */

require('dotenv').config();
const { defaultTemplate } = require('../templates/defaultTemplate');
const { assignSections } = require('./orchestratorAgent');
const { assistantDefinitions } = require('./assistantDefinitions');
const responsesAgent = require('./responsesAgent');
const fs = require('fs');
const path = require('path');

// Initialize tracking and state
let currentProposalId = null;

/**
 * Parse JSON safely from response text
 * 
 * @param {String} raw - Raw text that may contain JSON
 * @param {String} label - Label for error reporting
 * @returns {Object} Parsed JSON object
 */
function parseJson(raw, label) {
  console.log(`[flowAgent] Attempting to parse JSON for ${label}`);
  
  // If it's an undefined or null value
  if (raw === undefined || raw === null) {
    console.error(`[flowAgent] Empty response for ${label}: ${raw}`);
    throw new Error(`No JSON response for ${label}`);
  }
  
  // If it's already an object (not a string), try to use it directly
  if (typeof raw === 'object') {
    console.log(`[flowAgent] Response for ${label} is already an object, checking properties`);
    
    // Check for output property in the format returned by Responses API
    if (raw.output && Array.isArray(raw.output) && raw.output.length > 0) {
      // Try to extract JSON from the output content
      for (const outputItem of raw.output) {
        if (outputItem.content && Array.isArray(outputItem.content)) {
          for (const contentItem of outputItem.content) {
            if (contentItem.text && typeof contentItem.text === 'string') {
              // Try to extract JSON from the text
              console.log(`[flowAgent] Found text content in output, attempting to parse`);
              try {
                return extractJsonFromText(contentItem.text, label);
              } catch (err) {
                console.log(`[flowAgent] Could not extract JSON from output text: ${err.message}`);
                // Continue checking other properties
              }
            }
          }
        }
      }
    }
    
    // If we have output_text property
    if (raw.output_text && typeof raw.output_text === 'string') {
      console.log(`[flowAgent] Found output_text property, attempting to parse`);
      try {
        return extractJsonFromText(raw.output_text, label);
      } catch (err) {
        console.log(`[flowAgent] Could not extract JSON from output_text: ${err.message}`);
        // Continue checking other properties
      }
    }
    
    // Return the raw object if no processing succeeded
    console.log(`[flowAgent] Using raw object as JSON for ${label}`);
    return raw;
  }
  
  // Handle string responses
  if (typeof raw === 'string') {
    return extractJsonFromText(raw, label);
  }
  
  // If it's neither an object nor a string, throw an error
  console.error(`[flowAgent] Unexpected type for ${label}: ${typeof raw}`);
  throw new Error(`Unexpected response type for ${label}: ${typeof raw}`);
}

// Helper function to extract JSON from text (markdown, code blocks, etc.)
function extractJsonFromText(text, label) {
  const trimmed = text.trim();
  if (!trimmed || trimmed === 'undefined') {
    console.error(`[flowAgent] Undefined or empty response for ${label}`);
    throw new Error(`No JSON response for ${label}`);
  }
  
  // First try: If the entire response is valid JSON, parse it directly
  try {
    return JSON.parse(trimmed);
  } catch (directParseError) {
    console.log(`[flowAgent] Direct JSON parse failed, attempting to extract JSON from text: ${directParseError.message}`);
  }
  
  // Second try: Find first opening brace and last closing brace for JSON object
  const first = trimmed.indexOf('{');
  const last = trimmed.lastIndexOf('}');
  
  // Find first opening bracket and last closing bracket for JSON array
  const firstArray = trimmed.indexOf('[');
  const lastArray = trimmed.lastIndexOf(']');
  
  // Determine if we're dealing with an object or array
  let jsonStr;
  if (first >= 0 && last > first) {
    // It's an object
    jsonStr = trimmed.substring(first, last + 1);
  } else if (firstArray >= 0 && lastArray > firstArray) {
    // It's an array
    jsonStr = trimmed.substring(firstArray, lastArray + 1);
  } else {
    // Try to handle cases where markdown formatting might be present
    const codeBlockStart = trimmed.indexOf("```json");
    if (codeBlockStart >= 0) {
      const codeContentStart = trimmed.indexOf("\n", codeBlockStart) + 1;
      const codeBlockEnd = trimmed.indexOf("```", codeContentStart);
      if (codeBlockEnd > codeContentStart) {
        jsonStr = trimmed.substring(codeContentStart, codeBlockEnd).trim();
        console.log(`[flowAgent] Extracted JSON from code block for ${label}`);
      }
    } else {
      // Try other code block formats (```javascript, etc.)
      const genericCodeBlockStart = trimmed.indexOf("```");
      if (genericCodeBlockStart >= 0) {
        const genericCodeContentStart = trimmed.indexOf("\n", genericCodeBlockStart) + 1;
        const genericCodeBlockEnd = trimmed.indexOf("```", genericCodeContentStart);
        if (genericCodeBlockEnd > genericCodeContentStart) {
          jsonStr = trimmed.substring(genericCodeContentStart, genericCodeBlockEnd).trim();
          console.log(`[flowAgent] Extracted JSON from generic code block for ${label}`);
        }
      }
    }
    
    // If still no JSON found
    if (!jsonStr) {
      console.error(`[flowAgent] JSON structure not found in ${label} response`);
      throw new Error(`Invalid JSON for ${label}`);
    }
  }
  
  // Try to parse the extracted JSON
  try {
    return JSON.parse(jsonStr);
  } catch (e) {
    console.error(`[flowAgent] JSON.parse error for ${label}:`, e.message);
    // Try to fix common JSON issues
    const fixAttempts = [
      // Replace single quotes with double quotes
      () => JSON.parse(jsonStr.replace(/'/g, '"')),
      // Replace unquoted keys with quoted keys
      () => JSON.parse(jsonStr.replace(/(\b\w+\b)(?=\s*:)/g, '"$1"')),
      // Fix trailing commas in objects
      () => JSON.parse(jsonStr.replace(/,\s*}/g, '}')),
      // Fix trailing commas in arrays
      () => JSON.parse(jsonStr.replace(/,\s*\]/g, ']')),
      // Add double quotes to keys and string values that seem to be missing them
      () => {
        let result = jsonStr;
        // Replace unquoted properties
        result = result.replace(/(\b\w+\b)(?=\s*:)/g, '"$1"');
        // Try to fix unquoted string values (simplistic approach)
        result = result.replace(/:(\s*)([A-Za-z][A-Za-z0-9_\s]+)(?=,|}|$)/g, ':"$2"');
        return JSON.parse(result);
      }
    ];
    
    // Try each fix attempt
    for (const fixAttempt of fixAttempts) {
      try {
        return fixAttempt();
      } catch (fixError) {
        // Continue to next attempt
      }
    }
    
    console.error(`[flowAgent] All JSON parsing attempts failed for ${label}`);
    console.error(`[flowAgent] JSON string was: ${jsonStr}`);
    throw new Error(`Invalid JSON for ${label}: ${e.message}`);
  }
}
      () => JSON.parse(jsonStr.replace(/'/g, '"')),
      // Replace unquoted keys with quoted keys
      () => JSON.parse(jsonStr.replace(/(\b\w+\b)(?=\s*:)/g, '"$1"')),
      // Fix trailing commas in objects
      () => JSON.parse(jsonStr.replace(/,\s*}/g, '}')),
      // Fix trailing commas in arrays
      () => JSON.parse(jsonStr.replace(/,\s*\]/g, ']')),
      // Add double quotes to keys and string values that seem to be missing them
      () => {
        let result = jsonStr;
        // Replace unquoted properties
        result = result.replace(/(\b\w+\b)(?=\s*:)/g, '"$1"');
        // Try to fix unquoted string values (simplistic approach)
        result = result.replace(/:(\s*)([A-Za-z][A-Za-z0-9_\s]+)(?=,|}|$)/g, ':"$2"');
        return JSON.parse(result);
      }
    ];
    
    // Try each fix attempt
    for (const fixAttempt of fixAttempts) {
      try {
        return fixAttempt();
      } catch (fixError) {
        // Continue to next attempt
      }
    }
    
    console.error(`[flowAgent] All JSON parsing attempts failed for ${label}`);
    console.error(`[flowAgent] JSON string was: ${jsonStr}`);
    throw new Error(`Invalid JSON for ${label}: ${e.message}`);
  }
}

/**
 * Mock customer agent for testing environments
 * 
 * @param {String} question - The question to ask
 * @param {Object} brief - The project brief
 * @returns {String} Mock customer response
 */
function mockCustomerAnswer(question, brief) {
  return `Mock answer to "${question}" for ${brief.client_name}`;
}

/**
 * Run the complete proposal generation workflow
 * 
 * @param {Object} options - Configuration options
 * @param {Object} options.brief - The customer brief
 * @param {String} options.customerAnswers - Initial customer answers (optional)
 * @param {String} options.customerReviewAnswers - Initial customer review answers (optional)
 * @returns {Object} The complete proposal output
 */
async function runFullFlow({ brief, customerAnswers: initialCustomerAnswers, customerReviewAnswers: initialCustomerReviewAnswers }) {
  // Reset progress tracking for new proposal
  responsesAgent.resetProgress();
  
  // Generate unique proposal ID
  currentProposalId = `proposal-${Date.now()}`;
  console.log(`[flowAgent] Starting new proposal generation (ID: ${currentProposalId})`);
  console.log(`[flowAgent] Received initial customerAnswers: ${initialCustomerAnswers}`);
  console.log(`[flowAgent] Received initial customerReviewAnswers: ${initialCustomerReviewAnswers}`);

  // --- Ensure all key file IDs are declared and always available ---
  let briefFileId = null;
  let analysisFileId = null;
  let assignmentsFileId = null;
  let questionsFileId = null;
  let answersFileId = null;
  let customerReviewAnswersFileId = null;
  let manifestFileId = null;
  let finalApprovalFileId = null;
  let finalProposalFileId = null;

  // Mock flow for testing environments
  if (process.env.NODE_ENV === 'test' || !process.env.OPENAI_API_KEY) {
    const analysis = `Brief analysis for ${brief.client_name}`;
    const sections = Object.keys(defaultTemplate);
    const assignments = await assignSections({ sections, title: '', client: brief.client_name, details: brief.project_description });
    
    const organizedQuestions = {
      organizedQuestions: [
        {
          theme: "Business Objectives",
          questions: [
            {
              question: "What are your primary business goals for this project?",
              source: "sp_Account_Manager",
              id: "q1"
            },
            {
              question: "How do you measure success for this initiative?",
              source: "sp_Commercial_Manager",
              id: "q2"
            }
          ]
        },
        {
          theme: "Technical Requirements",
          questions: [
            {
              question: "What are your existing systems that need integration?",
              source: "sp_Solution_Architect",
              id: "q3"
            }
          ]
        }
      ]
    };
    
    const customerAnswers = initialCustomerAnswers || `Here are my answers to your questions:

## Business Objectives
q1. Our primary business goals are to improve data quality and customer experience.
q2. We measure success through reduced errors and improved customer satisfaction scores.

## Technical Requirements
q3. We need integration with our Oracle ERP system and Salesforce CRM.`;
    
    const questionsAndAnswers = {
      organizedQuestions,
      customerAnswers
    };
    
    const development = {};
    for (const section of sections) {
      development[section] = `Draft for ${section} incorporating all customer answers about business objectives and technical requirements.`;
    }
    
    const reviews = {};
    sections.forEach(sec => {
      reviews[sec] = {
        review: 'Review feedback from the Quality Manager covering all aspects of the section including strategy, sales, technology, delivery, and commercial considerations.',
        customerQuestions: ['How do you plan to measure ROI?', 'What is your timeline for implementation?'],
        customerAnswers: initialCustomerReviewAnswers || 'Mock answers to review questions'
      };
    });
    
    const revisedDevelopment = {};
    sections.forEach(sec => {
      revisedDevelopment[sec] = `Revised draft for ${sec} after incorporating feedback and customer answers.`;
    });
    
    const approval = 'Final approval granted';
    const assembled = sections.map(sec => revisedDevelopment[sec]).join('\n\n');
    return { 
      analysis, 
      sections, 
      assignments, 
      questionsAndAnswers, 
      development, 
      reviews, 
      revisedDevelopment,
      approval, 
      assembled 
    };
  }
  
  // PRODUCTION FLOW USING RESPONSES API
  try {
    console.log(`[flowAgent] Starting production flow using Responses API`);
    const sections = Object.keys(defaultTemplate);
    
    // ===== PHASE 1: Brief Analysis & Planning =====
    
    // Step 1: Brief analysis
    console.log("[flowAgent] Phase 1.1: Starting brief analysis");
    
    briefFileId = await responsesAgent.createAndUploadFile(
      JSON.stringify(brief, null, 2),
      `${currentProposalId}_brief.json`
    );
    if (!briefFileId) {
      throw new Error("Failed to upload brief file or fileId missing.");
    }
    
    const analysisPrompt = "Analyze the provided customer brief thoroughly. Consider all aspects including business objectives, technical requirements, commercial aspects, and potential challenges. Provide a comprehensive assessment that will guide the proposal development process.";
    
    const analysisResponse = await responsesAgent.createInitialResponse(
      analysisPrompt,
      [briefFileId],
      "BriefAnalysis"
    );
    const analysis = analysisResponse.response || "Unable to generate analysis";
    
    responsesAgent.trackTokenUsage(analysisResponse, currentProposalId, "Phase1_BriefAnalysis");
    
    analysisFileId = await responsesAgent.createAndUploadFile(
      analysis,
      `${currentProposalId}_analysis.md`
    );
    if (!analysisFileId) {
      throw new Error("Failed to upload analysis file or fileId missing.");
    }
    
    responsesAgent.updateProgressStatus(currentProposalId, "Phase1_BriefAnalysis", "completed", {
      analysisFileId: analysisFileId
    });
    
    console.log("[flowAgent] Brief analysis completed");
    
    // Step 2: Section assignments
    console.log("[flowAgent] Phase 1.2: Starting section assignments");
    
    const availableRoles = Object.keys(assistantDefinitions).filter(role => role.startsWith('sp_'));
    
    const assignPrompt = `Based on the brief and analysis, assign these sections: ${sections.join(', ')}.
  
IMPORTANT: You must ONLY use these exact roles in your assignments: ${availableRoles.join(', ')}

Return a JSON object mapping each section name to exactly one of these role names.`;
    
    const assignResponse = await responsesAgent.createInitialResponse(
      assignPrompt,
      [briefFileId, analysisFileId],
      "SectionAssignments"
    );
    
    // Add extensive logging to debug the issue
    console.log(`[flowAgent] [DEBUG] Section Assignments Response Type: ${typeof assignResponse.response}`);
    
    // Safely log JSON representation
    try {
        const jsonString = JSON.stringify(assignResponse);
        if (typeof jsonString === 'string') {
            console.log(`[flowAgent] [DEBUG] Section Assignments Full Response: ${jsonString.substring(0, 1000)}`);
        } else {
            console.log('[flowAgent] [DEBUG] Section Assignments Full Response: Unable to stringify response');
        }
    } catch (e) {
        console.log(`[flowAgent] [DEBUG] Could not stringify assignResponse: ${e.message}`);
    }
    
    // Safely log text property with type checking
    if (assignResponse.text !== undefined) {
        const textType = typeof assignResponse.text;
        console.log(`[flowAgent] [DEBUG] Section Assignments Text Type: ${textType}`);
        if (textType === 'string') {
            console.log(`[flowAgent] [DEBUG] Section Assignments Text: ${assignResponse.text.substring(0, 1000)}`);
        } else {
            console.log(`[flowAgent] [DEBUG] Section Assignments Text is not a string:`, assignResponse.text);
        }
    } else {
        console.log(`[flowAgent] [DEBUG] Section Assignments Text: Property undefined`);
    }
    
    // Safely log response property with type checking
    if (assignResponse.response !== undefined) {
        const respType = typeof assignResponse.response;
        console.log(`[flowAgent] [DEBUG] Section Assignments Response Type: ${respType}`);
        if (respType === 'string') {
            console.log(`[flowAgent] [DEBUG] Section Assignments Response: ${assignResponse.response.substring(0, 1000)}`);
        } else {
            console.log(`[flowAgent] [DEBUG] Section Assignments Response is not a string:`, assignResponse.response);
        }
    } else {
        console.log(`[flowAgent] [DEBUG] Section Assignments Response: Property undefined`);
    }
    
    // Try multiple properties in order of preference
    let responseText;
    let assignments;
    
    try {
      // Try text property first if it's a string
      if (assignResponse.text && typeof assignResponse.text === 'string') {
        console.log(`[flowAgent] Trying to parse text property (string)`);
        responseText = assignResponse.text;
        assignments = parseJson(responseText, "section assignments (text)");
      } 
      // Then try response property if it's a string
      else if (assignResponse.response && typeof assignResponse.response === 'string') {
        console.log(`[flowAgent] Trying to parse response property (string)`);
        responseText = assignResponse.response;
        assignments = parseJson(responseText, "section assignments (response)");
      } 
      // Then try the whole response object as a fallback
      else {
        console.log(`[flowAgent] No valid string property found, trying whole response object`);
        assignments = parseJson(assignResponse, "section assignments (full object)");
      }
    } catch (error) {
      console.error(`[flowAgent] Error parsing section assignments: ${error.message}`);
      throw new Error(`Failed to parse section assignments: ${error.message}`);
    }
    
    responsesAgent.trackTokenUsage(assignResponse, currentProposalId, "Phase1_SectionAssignments");
    
    assignmentsFileId = await responsesAgent.createAndUploadFile(
      JSON.stringify(assignments, null, 2),
      `${currentProposalId}_assignments.json`
    );
    if (!assignmentsFileId) {
      throw new Error("Failed to upload assignments file or fileId missing.");
    }
    
    responsesAgent.updateProgressStatus(currentProposalId, "Phase1_SectionAssignments", "completed", {
      assignmentsFileId: assignmentsFileId
    });
    
    console.log("[flowAgent] Section assignments completed");
    
    // Step 3: Generate clarifying questions from each specialist (PARALLEL)
    console.log("[flowAgent] Phase 1.3: Generating clarifying questions");
    
    const specialistRoles = Object.keys(assistantDefinitions).filter(role => 
      role.startsWith('sp_') && !role.includes('Collaboration_Orchestrator')
    );
    
    console.log(`[flowAgent] Identified ${specialistRoles.length} specialist roles for question generation`);
    
    responsesAgent.updateProgressStatus(currentProposalId, "Phase1_ClarifyingQuestions", "in-progress", {
      specialists: specialistRoles.reduce((acc, role) => {
        acc[role] = { status: "pending", questions: [] };
        return acc;
      }, {})
    });
    
    const questionPromises = [];
    const specialistQuestions = {};
    
    for (const role of specialistRoles) {
      const questionPrompt = `As a ${role.replace('sp_', '')}, review the customer brief and generate 2-3 important strategic clarifying questions that would help you better understand the customer's needs and provide an expert proposal. 
    
Your questions should:
- Be relevant to your specific expertise and role
- Focus on understanding business needs, constraints, and priorities
- NOT ask how to write or structure the proposal
- NOT ask section-specific questions
- Demonstrate your expertise in your domain

Return your questions as a JSON array in this format:
[
  {
    "question": "Your first question text here",
    "rationale": "Brief explanation of why this question is important from your role's perspective",
    "category": "General topic/category for this question (e.g., 'Technical Requirements', 'Timeline', 'Business Objectives')"
  },
  ...more questions...
]`;
      
      const questionPromise = (async () => {
        try {
          console.log(`[flowAgent] Requesting questions from ${role}`);
          
          const response = await responsesAgent.createInitialResponse(
            questionPrompt,
            [briefFileId, analysisFileId],
            role
          );
          
          responsesAgent.trackTokenUsage(response, currentProposalId, `Phase1_ClarifyingQuestions_${role}`);
          
          try {
            const responseStr = response.response.trim();
            const jsonStartIdx = responseStr.indexOf('[');
            const jsonEndIdx = responseStr.lastIndexOf(']') + 1;
            
            if (jsonStartIdx >= 0 && jsonEndIdx > jsonStartIdx) {
              const jsonStr = responseStr.substring(jsonStartIdx, jsonEndIdx);
              const parsedQuestions = JSON.parse(jsonStr);
              
              parsedQuestions.forEach(q => {
                q.role = role;
              });
              
              specialistQuestions[role] = parsedQuestions;
              
              responsesAgent.updateProgressStatus(currentProposalId, "Phase1_ClarifyingQuestions", "in-progress", {
                specialists: {
                  [role]: { status: "completed", questions: parsedQuestions }
                }
              });
              
              console.log(`[flowAgent] Added ${parsedQuestions.length} questions from ${role}`);
            } else {
              console.error(`[flowAgent] Could not find valid JSON in response from ${role}`);
              responsesAgent.updateProgressStatus(currentProposalId, "Phase1_ClarifyingQuestions", "in-progress", {
                specialists: { [role]: { status: "error", error: "No JSON array in response" } }
              });
            }
          } catch (e) {
            console.error(`[flowAgent] Error parsing questions from ${role}:`, e);
            responsesAgent.updateProgressStatus(currentProposalId, "Phase1_ClarifyingQuestions", "in-progress", {
                specialists: { [role]: { status: "error", error: e.message } }
            });
          }
        } catch (error) {
          console.error(`[flowAgent] Error getting questions from ${role}:`, error);
          responsesAgent.updateProgressStatus(currentProposalId, "Phase1_ClarifyingQuestions", "in-progress", {
              specialists: { [role]: { status: "error", error: error.message } }
          });
        }
      })();
      
      questionPromises.push(questionPromise);
    }
    
    await Promise.all(questionPromises);
    
    const allQuestions = [];
    Object.values(specialistQuestions).forEach(questions => {
      if (Array.isArray(questions)) {
        allQuestions.push(...questions);
      }
    });
    
    console.log(`[flowAgent] Collected ${allQuestions.length} questions from all specialists`);
    
    const dedupePrompt = `I've collected clarifying questions from various specialists regarding the customer brief. 
Please review these questions, remove duplicates or very similar questions, and organize them into logical groups or themes.

Format the final questions in a clear, organized manner that would be easy for the customer to respond to.

Here are all the questions:
${JSON.stringify(allQuestions, null, 2)}

Return the organized questions as a JSON object with the following structure:
{
  "organizedQuestions": [
    {
      "theme": "Theme/Category Name",
      "questions": [
        {
          "question": "The question text",
          "source": "Original role that suggested this question",
          "id": "q1" // Assign a simple ID to each question
        },
        ...more questions in this theme...
      ]
    },
    ...more themes...
  ]
}`;

    const organizedQuestionsResponse = await responsesAgent.createInitialResponse(
      dedupePrompt,
      [briefFileId, analysisFileId],
      "OrganizeQuestions"
    );
    
    responsesAgent.trackTokenUsage(organizedQuestionsResponse, currentProposalId, "Phase1_OrganizeQuestions");
    
    const organizedQuestions = parseJson(organizedQuestionsResponse.response, "organized questions");
    
    questionsFileId = await responsesAgent.createAndUploadFile(
      JSON.stringify(organizedQuestions, null, 2),
      `${currentProposalId}_questions.json`
    );
    if (!questionsFileId) {
      throw new Error("Failed to upload questions file or fileId missing.");
    }
    
    responsesAgent.updateProgressStatus(currentProposalId, "Phase1_ClarifyingQuestions", "completed", {
      questionsFileId: questionsFileId,
      organizedQuestions
    });
    
    console.log("[flowAgent] Question organization completed");
    
    // ===== PHASE 2: Q&A and Development =====
    
    // Step 4: Ask all questions to the customer
    console.log("[flowAgent] Phase 2.1: Customer Q&A");
    
    let customerAnswers;
    let answersFileId;

    if (initialCustomerAnswers) {
      console.log("[flowAgent] Using provided initial customer answers.");
      customerAnswers = initialCustomerAnswers;
      answersFileId = await responsesAgent.createAndUploadFile(
        customerAnswers,
        `${currentProposalId}_customer_answers_initial.md`
      );
      if (!answersFileId) {
        throw new Error("Failed to upload initial customer answers file or fileId missing.");
      }
    } else {
      let customerPrompt = `As our valued client, we'd like to ask you some clarifying questions about your project to ensure we create the most effective proposal for your needs. Please provide your responses to the following questions:\n\n`;
      
      organizedQuestions.organizedQuestions.forEach((theme, themeIndex) => {
        customerPrompt += `\n## ${theme.theme}\n\n`;
        theme.questions.forEach((q, qIndex) => {
          customerPrompt += `${q.id}. ${q.question}\n`;
        });
      });
      
      customerPrompt += `\n\nPlease provide thorough answers to each question. You may organize your response by theme or answer each question individually by referencing its ID.`;
      
      console.log("[flowAgent] Sending consolidated questions to customer");
      const customerAnswersResponse = await responsesAgent.createInitialResponse(
        customerPrompt,
        [briefFileId, questionsFileId],
        "CustomerAnswers"
      );
      
      responsesAgent.trackTokenUsage(customerAnswersResponse, currentProposalId, "Phase2_CustomerAnswers");
      
      customerAnswers = customerAnswersResponse.response;
      console.log("[flowAgent] Received comprehensive answers from customer");
      
      answersFileId = await responsesAgent.createAndUploadFile(
        customerAnswers,
        `${currentProposalId}_customer_answers.md`
      );
      if (!answersFileId) {
        throw new Error("Failed to upload customer answers file or fileId missing.");
      }
    }
    
    const questionsAndAnswers = {
      organizedQuestions,
      customerAnswers
    };
    
    responsesAgent.updateProgressStatus(currentProposalId, "Phase2_CustomerAnswers", "completed", {
      answersFileId: answersFileId
    });
    
    // Step 5: Section development by assignees (PARALLEL)
    console.log("[flowAgent] Phase 2.2: Starting section development");
    
    responsesAgent.updateProgressStatus(currentProposalId, "Phase2_SectionDrafts", "in-progress", {
      sections: sections.reduce((acc, section) => {
        acc[section] = { status: "pending", fileId: null };
        return acc;
      }, {})
    });
    
    const development = {};
    const sectionPromises = [];
    const sectionFileIds = {};
    const sectionMessageIds = {};
    
    for (const [section, role] of Object.entries(assignments)) {
      const sectionPromise = (async () => {
        try {
          const prompt = `Draft the "${section}" section of the proposal based on:
1. The initial project brief
2. The clarifying questions and customer answers
3. Your expertise as a ${role.replace('sp_', '')}

Your draft should be well-structured, persuasive, and demonstrate expert understanding of the customer's needs. Focus on providing value and addressing the customer's specific requirements as revealed through the Q&A process.`;

          console.log(`[flowAgent] Requesting draft for "${section}" from ${role}`);
          
          const sectionResponse = await responsesAgent.createInitialResponse(
            prompt,
            [briefFileId, analysisFileId, questionsFileId, answersFileId],
            role
          );
          
          responsesAgent.trackTokenUsage(sectionResponse, currentProposalId, `Phase2_DevelopSection_${section}`);
          
          development[section] = sectionResponse.response;
          sectionMessageIds[section] = sectionResponse.id;
          
          const sectionFileUploadResponse = await responsesAgent.createAndUploadFile(
            sectionResponse.response,
            `${currentProposalId}_${section.replace(/\s+/g, '_')}_draft.md`
          );
          if (!sectionFileUploadResponse) {
            throw new Error(`Failed to upload draft for section ${section} or fileId missing.`);
          }
          sectionFileIds[section] = sectionFileUploadResponse;
          
          responsesAgent.updateProgressStatus(currentProposalId, "Phase2_SectionDrafts", "in-progress", {
            sections: {
              [section]: { status: "completed", fileId: sectionFileIds[section] }
            }
          });
          
          console.log(`[flowAgent] Completed draft for "${section}"`);
        } catch (error) {
          console.error(`[flowAgent] Error drafting section "${section}":`, error);
          
          responsesAgent.updateProgressStatus(currentProposalId, "Phase2_SectionDrafts", "in-progress", {
            sections: {
              [section]: { status: "error", error: error.message }
            }
          });
        }
      })();
      
      sectionPromises.push(sectionPromise);
    }
    
    await Promise.all(sectionPromises);
    
    responsesAgent.updateProgressStatus(currentProposalId, "Phase2_SectionDrafts", "completed");
    
    console.log("[flowAgent] All section drafts completed");
    
    // ===== PHASE 3: Review and Revision =====
    
    // Step 6: Quality Manager Review Process
    console.log("[flowAgent] Phase 3.1: Starting Quality Manager reviews");
    
    const reviews = {};
    
    responsesAgent.updateProgressStatus(currentProposalId, "Phase3_Reviews", "in-progress", {
      sections: sections.reduce((acc, section) => {
        acc[section] = { 
          status: "pending", 
          fileId: null,
          customerQuestions: []
        };
        return acc;
      }, {})
    });
    
    const reviewPromises = [];
    const reviewFileIds = {};
    const reviewMessageIds = {};
    
    for (const [section, ownerRole] of Object.entries(assignments)) {
      const reviewPromise = (async () => {
        try {
          const draftSectionFileId = sectionFileIds[section];
          if (!draftSectionFileId) {
             throw new Error(`Missing draft file ID for section ${section} before review.`);
          }
          
          reviews[section] = {
            review: '',
            customerQuestions: [],
            customerAnswers: ''
          };
          
          console.log(`[flowAgent] Requesting Quality Manager review for "${section}"`);
          
          const qualityManagerReviewPrompt = `Please review the attached section draft ("${section}"). Provide feedback, suggested revisions, and any high-value questions for the customer.

Your feedback should be structured as a JSON object with the following keys:
- "generalFeedback": "Overall assessment of the section."
- "suggestedRevisions": "Specific, actionable revisions."
- "questionsForCustomer": ["Array of strings, only if essential and high-value. Otherwise, an empty array." ]
- "questionsForDraftingAgent": ["Array of strings for the original author (${ownerRole.replace('sp_', '')})."]

Focus on clarity, accuracy, persuasiveness, and alignment with the customer's brief and answers.`;
          
          const reviewResponse = await responsesAgent.createInitialResponse(
            qualityManagerReviewPrompt,
            [briefFileId, analysisFileId, questionsFileId, answersFileId, draftSectionFileId],
            "QualityManager"
          );
          
          responsesAgent.trackTokenUsage(reviewResponse, currentProposalId, `Phase3_ReviewSection_${section}`);
          
          const reviewJson = parseJson(reviewResponse.response, `review for ${section}`);
          reviews[section].review = reviewJson;
          reviewMessageIds[section] = reviewResponse.id;
          
          const reviewFileUploadResponse = await responsesAgent.createAndUploadFile(
            JSON.stringify(reviewJson, null, 2),
            `${currentProposalId}_${section.replace(/\s+/g, '_')}_review.json`
          );
          if (!reviewFileUploadResponse) {
            throw new Error(`Failed to upload review for section ${section} or fileId missing.`);
          }
          reviewFileIds[section] = reviewFileUploadResponse;
          
          responsesAgent.updateProgressStatus(currentProposalId, "Phase3_Reviews", "in-progress", {
            sections: {
              [section]: { 
                status: "completed", 
                fileId: reviewFileIds[section],
                customerQuestions: reviewJson.questionsForCustomer || []
              }
            }
          });
          
          console.log(`[flowAgent] Completed review for "${section}"`);
        } catch (error) {
          console.error(`[flowAgent] Error reviewing section "${section}":`, error);
          
          responsesAgent.updateProgressStatus(currentProposalId, "Phase3_Reviews", "in-progress", {
            sections: {
              [section]: { status: "error", error: error.message }
            }
          });
        }
      })();
      
      reviewPromises.push(reviewPromise);
    }
    
    await Promise.all(reviewPromises);
    
    responsesAgent.updateProgressStatus(currentProposalId, "Phase3_Reviews", "completed");
    
    console.log("[flowAgent] All section reviews completed");
    
    // Step 6B: Extract customer questions from Quality Manager reviews
    console.log("[flowAgent] Consolidating customer questions from reviews");
    
    const allCustomerQuestionsFromReviews = {};
    let hasReviewQuestions = false;
    
    for (const [section, reviewData] of Object.entries(reviews)) {
      if (reviewData.review && reviewData.review.questionsForCustomer && reviewData.review.questionsForCustomer.length > 0) {
        allCustomerQuestionsFromReviews[section] = reviewData.review.questionsForCustomer;
        hasReviewQuestions = true;
      }
    }
    
    let customerReviewAnswersFileId = null;
    let customerReviewAnswersText = initialCustomerReviewAnswers || "";

    if (hasReviewQuestions && !initialCustomerReviewAnswers) {
      console.log("[flowAgent] Sending review-generated questions to customer");
      
      let customerReviewQuestionsPrompt = `Based on our internal review of the draft proposal, we have some follow-up questions to help us refine the content. Please provide answers to the following questions:\n\n`;
      
      for (const [section, questionsArray] of Object.entries(allCustomerQuestionsFromReviews)) {
        customerReviewQuestionsPrompt += `\n## Questions regarding the "${section}" section:\n`;
        questionsArray.forEach((q, idx) => {
          customerReviewQuestionsPrompt += `${idx + 1}. ${q}\n`;
        });
      }
      
      customerReviewQuestionsPrompt += `\n\nYour answers will help us refine the proposal to better meet your needs.`;
      
      const customerReviewAnswersResponse = await responsesAgent.createInitialResponse(
        customerReviewQuestionsPrompt,
        [briefFileId],
        "CustomerReviewAnswers"
      );
      
      responsesAgent.trackTokenUsage(customerReviewAnswersResponse, currentProposalId, "Phase3_CustomerReviewAnswers");
      
      customerReviewAnswersText = customerReviewAnswersResponse.response;
      
      for (const section of Object.keys(allCustomerQuestionsFromReviews)) {
        if (reviews[section]) {
           reviews[section].customerAnswers = customerReviewAnswersText;
        }
      }
      
      const reviewAnswersFileUploadResponse = await responsesAgent.createAndUploadFile(
        customerReviewAnswersText,
        `${currentProposalId}_review_customer_answers.md`
      );
      if (!reviewAnswersFileUploadResponse) {
        throw new Error("Failed to upload customer review answers file or fileId missing.");
      }
      customerReviewAnswersFileId = reviewAnswersFileUploadResponse;
      
      responsesAgent.updateProgressStatus(currentProposalId, "Phase3_CustomerReviewAnswers", "completed", {
        fileId: customerReviewAnswersFileId
      });
    } else if (initialCustomerReviewAnswers) {
        console.log("[flowAgent] Using provided initial customer review answers.");
        const reviewAnswersFileUploadResponse = await responsesAgent.createAndUploadFile(
            initialCustomerReviewAnswers,
            `${currentProposalId}_review_customer_answers_initial.md`
        );
        if (!reviewAnswersFileUploadResponse) {
            throw new Error("Failed to upload initial customer review answers file or fileId missing.");
        }
        customerReviewAnswersFileId = reviewAnswersFileUploadResponse;
        for (const section of sections) {
            if (reviews[section]) {
                reviews[section].customerAnswers = initialCustomerReviewAnswers;
            }
        }
        responsesAgent.updateProgressStatus(currentProposalId, "Phase3_CustomerReviewAnswers", "completed", {
            fileId: customerReviewAnswersFileId,
            message: "Used pre-provided answers."
        });
    } else {
      responsesAgent.updateProgressStatus(currentProposalId, "Phase3_CustomerReviewAnswers", "skipped");
    }
    
    // Step 6C: Revise sections based on feedback and customer answers (PARALLEL)
    console.log("[flowAgent] Phase 3.3: Authors revising sections based on feedback");
    
    responsesAgent.updateProgressStatus(currentProposalId, "Phase3_Revisions", "in-progress", {
      sections: sections.reduce((acc, section) => {
        acc[section] = { status: "pending", fileId: null };
        return acc;
      }, {})
    });
    
    const revisedDevelopment = {};
    const revisionPromises = [];
    const revisedSectionFileIds = {};
    
    for (const [section, ownerRole] of Object.entries(assignments)) {
      const revisionPromise = (async () => {
        try {
          const reviewFileId = reviewFileIds[section];
          const draftSectionFileId = sectionFileIds[section];
          const previousMessageIdForRevision = reviewMessageIds[section];

          if (!reviewFileId || !draftSectionFileId || !previousMessageIdForRevision) {
            throw new Error(`Missing data for revising section ${section}: reviewFileId=${reviewFileId}, draftSectionFileId=${draftSectionFileId}, previousMessageId=${previousMessageIdForRevision}`);
          }

          const revisionPrompt = `Please revise the "${section}" section based on the attached Quality Manager's review and any new customer answers provided.

Your revision should:
- Address all feedback and questions from the Quality Manager.
- Incorporate new information from customer answers (if provided).
- Maintain the original intent and quality of the section.
- Ensure the revised section is polished and ready for final assembly.

Original Draft, QM Review, and potentially new Customer Answers are attached.`;

          const attachmentsForRevision = [
              briefFileId, 
              analysisFileId, 
              questionsFileId, 
              answersFileId, 
              draftSectionFileId, 
              reviewFileId
          ];

          if (customerReviewAnswersFileId) {
              attachmentsForRevision.push(customerReviewAnswersFileId);
          }
          
          console.log(`[flowAgent] Requesting revision for "${section}" from ${ownerRole}`);
          
          const revisionResponse = await responsesAgent.forkResponse(
            previousMessageIdForRevision,
            revisionPrompt,
            attachmentsForRevision,
            ownerRole
          );
          
          responsesAgent.trackTokenUsage(revisionResponse, currentProposalId, `Phase3_ReviseSection_${section}`);
          
          revisedDevelopment[section] = revisionResponse.response;
          
          const revisedFileUploadResponse = await responsesAgent.createAndUploadFile(
            revisionResponse.response,
            `${currentProposalId}_${section.replace(/\s+/g, '_')}_revised.md`
          );
          if (!revisedFileUploadResponse) {
            throw new Error(`Failed to upload revised section ${section} or fileId missing.`);
          }
          revisedSectionFileIds[section] = revisedFileUploadResponse;
          
          responsesAgent.updateProgressStatus(currentProposalId, "Phase3_Revisions", "in-progress", {
            sections: {
              [section]: { status: "completed", fileId: revisedSectionFileIds[section] }
            }
          });
          
          console.log(`[flowAgent] Completed revision for "${section}"`);
        } catch (error) {
          console.error(`[flowAgent] Error revising section "${section}":`, error);
          
          responsesAgent.updateProgressStatus(currentProposalId, "Phase3_Revisions", "in-progress", {
            sections: {
              [section]: { status: "error", error: error.message }
            }
          });
        }
      })();
      
      revisionPromises.push(revisionPromise);
    }
    
    await Promise.all(revisionPromises);
    
    responsesAgent.updateProgressStatus(currentProposalId, "Phase3_Revisions", "completed");
    
    console.log("[flowAgent] All section revisions completed");
    
    // ===== PHASE 4: Final Assembly =====
    
    // Step 7: Final Quality Manager review and approval
    console.log("[flowAgent] Phase 4.1: Final review and assembly");
    
    const revisedSectionsForApproval = sections.map(section => {
        const fileId = revisedSectionFileIds[section];
        if (!fileId) {
            console.warn(`[flowAgent] Missing revised file ID for section ${section} during final approval prep.`);
        }
        return {
            sectionName: section,
            content: revisedDevelopment[section] || "Content not available",
            fileId: fileId 
        };
    });

    const manifestContent = revisedSectionsForApproval.map(rs => `Section: ${rs.sectionName}\nFile ID: ${rs.fileId || 'N/A'}\n---`).join('\n');
    const manifestFileUploadResponse = await responsesAgent.createAndUploadFile(
        manifestContent, 
        `${currentProposalId}_final_review_manifest.txt`
    );
    if (!manifestFileUploadResponse) {
        throw new Error("Failed to upload final review manifest file or fileId missing.");
    }
    manifestFileId = manifestFileUploadResponse;
    
    const finalReviewPrompt = `All sections have been drafted, reviewed, and revised. Please perform a final review of all attached revised sections. 
Confirm that the proposal is cohesive, addresses all customer requirements, and is of high quality.

If approved, respond with "Final approval granted." 
If not, provide specific reasons and outstanding issues.

A manifest file (${manifestFileId}) is attached listing all revised section files. The individual section files are also attached.`;

    const attachmentsForFinalReview = [
        briefFileId, 
        analysisFileId, 
        questionsFileId, 
        answersFileId,
        manifestFileId,
        ...revisedSectionsForApproval.map(rs => rs.fileId).filter(id => id)
    ];

    if (customerReviewAnswersFileId) {
        attachmentsForFinalReview.push(customerReviewAnswersFileId);
    }
    
    const finalApprovalResponse = await responsesAgent.createInitialResponse(
      finalReviewPrompt,
      attachmentsForFinalReview,
      "QualityManager"
    );
    
    responsesAgent.trackTokenUsage(finalApprovalResponse, currentProposalId, "Phase4_FinalApproval");
    
    const finalApprovalContent = finalApprovalResponse.response;
    
    const finalApprovalFileUploadResponse = await responsesAgent.createAndUploadFile(
      finalApprovalContent,
      `${currentProposalId}_final_approval.txt`
    );
    if (!finalApprovalFileUploadResponse) {
      throw new Error("Failed to upload final approval file or fileId missing.");
    }
    finalApprovalFileId = finalApprovalFileUploadResponse;
    
    responsesAgent.updateProgressStatus(currentProposalId, "Phase4_FinalApproval", "completed", {
      approvalFileId: finalApprovalFileId,
      approvalContent: finalApprovalContent
    });
    
    console.log("[flowAgent] Final QM approval received");
    
    // Step 8: Assemble final proposal
    console.log("[flowAgent] Phase 4.2: Assembling final proposal");
    
    const assembledProposalContent = sections.map(section => revisedDevelopment[section] || `Error: Content for section '${section}' was not generated.`).join('\n\n---\n\n');
    
    const finalProposalFileUploadResponse = await responsesAgent.createAndUploadFile(
      assembledProposalContent,
      `${currentProposalId}_final_proposal.md`
    );
    if (!finalProposalFileUploadResponse) {
      throw new Error("Failed to upload final proposal file or fileId missing.");
    }
    finalProposalFileId = finalProposalFileUploadResponse;
    
    responsesAgent.updateProgressStatus(currentProposalId, "Phase4_Assembly", "completed", {
      finalProposalFileId: finalProposalFileId
    });
    
    console.log("[flowAgent] Final proposal assembled");
    
    const finalReport = responsesAgent.getTokenUsageReport();
    console.log("[flowAgent] Final Token Usage Report:", JSON.stringify(finalReport, null, 2));
    
    // Construct file paths for the summary
    const allGeneratedFiles = [];
    const addPath = (filePath) => { if (filePath) allGeneratedFiles.push(filePath); };

    addPath(briefFileId ? `/uploads/${currentProposalId}/${currentProposalId}_brief.json` : null);
    addPath(analysisFileId ? `/uploads/${currentProposalId}/${currentProposalId}_analysis.md` : null);
    addPath(assignmentsFileId ? `/uploads/${currentProposalId}/${currentProposalId}_assignments.json` : null);
    addPath(questionsFileId ? `/uploads/${currentProposalId}/${currentProposalId}_questions.json` : null);
    if (initialCustomerAnswers) {
        addPath(answersFileId ? `/uploads/${currentProposalId}/${currentProposalId}_customer_answers_initial.md` : null);
    } else {
        addPath(answersFileId ? `/uploads/${currentProposalId}/${currentProposalId}_customer_answers.md` : null);
    }
    sections.forEach(section => {
        const s_ = section.replace(/\s+/g, '_');
        addPath(sectionFileIds[section] ? `/uploads/${currentProposalId}/${currentProposalId}_${s_}_draft.md` : null);
        addPath(reviewFileIds[section] ? `/uploads/${currentProposalId}/${currentProposalId}_${s_}_review.json` : null);
        addPath(revisedSectionFileIds[section] ? `/uploads/${currentProposalId}/${currentProposalId}_${s_}_revised.md` : null);
    });
    if (initialCustomerReviewAnswers) {
        addPath(customerReviewAnswersFileId ? `/uploads/${currentProposalId}/${currentProposalId}_review_customer_answers_initial.md` : null);
    } else if (customerReviewAnswersFileId) {
        addPath(customerReviewAnswersFileId ? `/uploads/${currentProposalId}/${currentProposalId}_review_customer_answers.md` : null);
    }
    addPath(manifestFileId ? `/uploads/${currentProposalId}/${currentProposalId}_final_review_manifest.txt` : null);
    addPath(finalApprovalFileId ? `/uploads/${currentProposalId}/${currentProposalId}_final_approval.txt` : null);
    addPath(finalProposalFileId ? `/uploads/${currentProposalId}/${currentProposalId}_final_proposal.md` : null);

    return {
      flowData: {
        proposalId: currentProposalId,
        briefFileId,
        briefAnalysis: analysis,
        analysisFileId,
        sectionAssignments: assignments,
        assignmentsFileId,
        clarifyingQuestions: organizedQuestions,
        questionsFileId,
        customerAnswers,
        customerAnswersFileId: answersFileId,
        sectionDrafts: sections.reduce((acc, section) => {
          acc[section] = { content: development[section], fileId: sectionFileIds[section] };
          return acc;
        }, {}),
        sectionReviews: sections.reduce((acc, section) => {
          acc[section] = { reviewContent: reviews[section].review, customerQuestions: reviews[section].customerQuestions, customerAnswers: reviews[section].customerAnswers, fileId: reviewFileIds[section] };
          return acc;
        }, {}),
        customerReviewAnswersFileId: customerReviewAnswersFileId,
        revisedSections: sections.reduce((acc, section) => {
          acc[section] = { content: revisedDevelopment[section], fileId: revisedSectionFileIds[section] };
          return acc;
        }, {}),
        finalApprovalContent,
        finalApprovalFileId,
        assembledProposalContent,
        finalProposalFileId
      },
      summary: {
        status: 'completed',
        message: 'Flow completed successfully.',
        totalTokensUsed: finalReport.overallTokens.total, // Corrected path to total tokens
        progressUpdates: finalReport.componentDetails, // Or finalReport.phaseBreakdown depending on desired granularity
        filesGenerated: allGeneratedFiles // Use the constructed list of file paths
      }
    };
  } catch (error) {
    console.error(`[flowAgent] CRITICAL ERROR in runFullFlow (ID: ${currentProposalId}):`, error.message);
    console.error(`[flowAgent] Error stack: ${error.stack}`);
    responsesAgent.updateProgressStatus(currentProposalId, "CriticalError", "failed", {
      error: error.message,
      stack: error.stack,
    });
    const finalReport = responsesAgent.getTokenUsageReport();
    console.log("[flowAgent] Token Usage Report on Failure:", JSON.stringify(finalReport, null, 2));
    // Construct file paths for the summary even on failure, if possible
    const errorGeneratedFiles = [];
    const addErrorPath = (filePath) => { if (filePath) errorGeneratedFiles.push(filePath); };

    // Attempt to gather any file IDs that were successfully created before the error
    // This is a simplified version; a more robust solution might involve checking progress status
    addErrorPath(briefFileId ? `/uploads/${currentProposalId}/${currentProposalId}_brief.json` : null);
    addErrorPath(analysisFileId ? `/uploads/${currentProposalId}/${currentProposalId}_analysis.md` : null);
    // ... (add other file IDs as they become available through the flow)

    // It's important to ensure finalReport and its properties are defined before accessing them
    const totalTokens = finalReport && finalReport.overallTokens ? finalReport.overallTokens.total : 0;
    const progress = finalReport && finalReport.componentDetails ? finalReport.componentDetails : {};

    // Return a partial summary if possible
    // Consider what information is most useful to return in an error state
    // For now, we'll re-throw the error as the primary way to signal failure.
    // The console logs above will capture the token report.
    throw error; 
  }
}

module.exports = { runFullFlow };
